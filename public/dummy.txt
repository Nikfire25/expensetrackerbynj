import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import type { PayloadAction } from "@reduxjs/toolkit";
import { authService } from "../services/authService";

interface User {
  id: number;
  email: string;
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

// --------------------
// Load from sessionStorage
// --------------------
const storedUser = sessionStorage.getItem("user");
const storedToken = sessionStorage.getItem("token");

const initialState: AuthState = {
  user: storedUser ? JSON.parse(storedUser) : null,
  token: storedToken ?? null,
  isAuthenticated: !!storedToken,
  isLoading: false,
  error: null,
};

// --------------------
// Thunks
// --------------------
export const loginUser = createAsyncThunk(
  "auth/login",
  async (credentials: { email: string; password: string }, thunkAPI) => {
    try {
      return await authService.login(credentials.email, credentials.password);
    } catch {
      return thunkAPI.rejectWithValue("Invalid email or password");
    }
  },
);

export const registerUser = createAsyncThunk(
  "auth/register",
  async (credentials: { email: string; password: string }, thunkAPI) => {
    try {
      return await authService.register(
        credentials.email,
        credentials.password,
      );
    } catch {
      return thunkAPI.rejectWithValue("Registration failed");
    }
  },
);

// --------------------
// Slice
// --------------------
const authSlice = createSlice({
  name: "auth",
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
      state.isAuthenticated = false;
      state.error = null;

      sessionStorage.removeItem("user");
      sessionStorage.removeItem("token");
    },
  },
  extraReducers: (builder) => {
    builder
      // LOGIN
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action: PayloadAction<any>) => {
        state.isLoading = false;
        state.user = action.payload.user;
        state.token = action.payload.accessToken;
        state.isAuthenticated = true;

        // âœ… SAVE TO SESSION STORAGE
        sessionStorage.setItem("user", JSON.stringify(action.payload.user));
        sessionStorage.setItem("token", action.payload.accessToken);
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // REGISTER
      .addCase(registerUser.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(registerUser.fulfilled, (state) => {
        state.isLoading = false;
      })
      .addCase(registerUser.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      });
  },
});

export const { logout } = authSlice.actions;
export default authSlice.reducer; this is my authSlice import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import type { PayloadAction } from "@reduxjs/toolkit";
import type { RootState } from "./store";
import { transactionsService } from "../services/transactionsService";

/* =======================
   Interfaces
======================= */

export interface Transaction {
  id: string;
  title: string;
  amount: number;
  isExpense: boolean;
  userEmail: string;
}

export interface TransactionPayload {
  title: string;
  amount: number;
  isExpense: boolean;
  userEmail: string;
}

/* =======================
   State
======================= */

interface TransactionState {
  transactions: Transaction[];
  balance: number;
  income: number;
  expense: number;
  isLoading: boolean;
  error: string | null;
}

const initialState: TransactionState = {
  transactions: [],
  balance: 0,
  income: 0,
  expense: 0,
  isLoading: false,
  error: null,
};

/* =======================
   Async Thunks
======================= */

/**
 * Fetch transactions
 * Backend returns ALL transactions
 * Frontend filters by logged-in user
 */
export const fetchTransactions = createAsyncThunk<
  Transaction[],
  void,
  { state: RootState }
>("transactions/fetch", async (_, thunkAPI) => {
  try {
    const state = thunkAPI.getState();
    const token = state.auth.token!;
    const userEmail = state.auth.user?.email;

    const allTransactions = await transactionsService.getTransactions(token);

    // ðŸ”¥ FRONTEND FILTERING
    return allTransactions.filter((tx) => tx.userEmail === userEmail);
  } catch {
    return thunkAPI.rejectWithValue("Failed to fetch transactions");
  }
});

/**
 * Create transaction
 */
export const createTransaction = createAsyncThunk<
  Transaction,
  TransactionPayload,
  { state: RootState }
>("transactions/create", async (transaction, thunkAPI) => {
  try {
    const token = thunkAPI.getState().auth.token!;
    return await transactionsService.addTransaction(transaction, token);
  } catch {
    return thunkAPI.rejectWithValue("Failed to add transaction");
  }
});

/**
 * Update transaction
 */
export const updateTransactionAPI = createAsyncThunk<
  Transaction,
  Transaction,
  { state: RootState }
>("transactions/update", async (transaction, thunkAPI) => {
  try {
    const token = thunkAPI.getState().auth.token!;
    return await transactionsService.updateTransaction(transaction, token);
  } catch {
    return thunkAPI.rejectWithValue("Failed to update transaction");
  }
});

/**
 * Delete transaction
 */
export const deleteTransactionAPI = createAsyncThunk<
  string,
  string,
  { state: RootState }
>("transactions/delete", async (id, thunkAPI) => {
  try {
    const token = thunkAPI.getState().auth.token!;
    await transactionsService.deleteTransaction(id, token);
    return id;
  } catch {
    return thunkAPI.rejectWithValue("Failed to delete transaction");
  }
});

/* =======================
   Slice
======================= */

const transactionSlice = createSlice({
  name: "transactions",
  initialState,
  reducers: {
    calculateBalance: (state) => {
      state.balance = state.transactions.reduce(
        (acc, tx) => acc + (tx.isExpense ? -tx.amount : tx.amount),
        0,
      );

      state.income = state.transactions.reduce(
        (acc, tx) => (!tx.isExpense ? acc + tx.amount : acc),
        0,
      );

      state.expense = state.transactions.reduce(
        (acc, tx) => (tx.isExpense ? acc + tx.amount : acc),
        0,
      );
    },

    clearTransactionsOnLogout: (state) => {
      state.transactions = [];
      state.balance = 0;
      state.income = 0;
      state.expense = 0;
      state.error = null;
      state.isLoading = false;
    },
  },
  extraReducers: (builder) => {
    builder

      /* ---------- FETCH ---------- */
      .addCase(fetchTransactions.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        fetchTransactions.fulfilled,
        (state, action: PayloadAction<Transaction[]>) => {
          state.isLoading = false;
          state.transactions = action.payload;
        },
      )
      .addCase(fetchTransactions.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      /* ---------- CREATE ---------- */
      .addCase(createTransaction.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(
        createTransaction.fulfilled,
        (state, action: PayloadAction<Transaction>) => {
          state.isLoading = false;
          state.transactions.push(action.payload);
        },
      )
      .addCase(createTransaction.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      /* ---------- UPDATE ---------- */
      .addCase(
        updateTransactionAPI.fulfilled,
        (state, action: PayloadAction<Transaction>) => {
          const index = state.transactions.findIndex(
            (tx) => tx.id === action.payload.id,
          );
          if (index !== -1) {
            state.transactions[index] = action.payload;
          }
        },
      )

      /* ---------- DELETE ---------- */
      .addCase(
        deleteTransactionAPI.fulfilled,
        (state, action: PayloadAction<string>) => {
          state.transactions = state.transactions.filter(
            (tx) => tx.id !== action.payload,
          );
        },
      );
  },
});

export const { calculateBalance, clearTransactionsOnLogout } =
  transactionSlice.actions;

export default transactionSlice.reducer; this is my transactionSlice import axios from "axios";

const API_URL = "http://localhost:3001";

export interface LoginPayload {
  email: string;
  password: string;
}

export const authService = {
  register: async (email: string, password: string) => {
    const res = await axios.post(`${API_URL}/register`, { email, password });
    return res.data;
  },

  login: async (email: string, password: string) => {
    const res = await axios.post(`${API_URL}/login`, { email, password });
    return res.data;
  },
}; this is my authService // services/transactionsService.ts
import axios from "axios";
import type {
  Transaction,
  TransactionPayload,
} from "../store/transactionSlice";

const API_URL = "http://localhost:3001/transactions";

export const transactionsService = {
  getTransactions: async (token: string) => {
    const res = await axios.get(API_URL, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return res.data as Transaction[];
  },

  addTransaction: async (transaction: TransactionPayload, token: string) => {
    const res = await axios.post(API_URL, transaction, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return res.data as Transaction;
  },

  updateTransaction: async (transaction: Transaction, token: string) => {
    const res = await axios.put(`${API_URL}/${transaction.id}`, transaction, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return res.data as Transaction;
  },

  deleteTransaction: async (id: string, token: string) => {
    await axios.delete(`${API_URL}/${id}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    return id;
  },
}; this is my transactionsService import { useEffect, useState } from "react";
import { useSelector, useDispatch } from "react-redux";
import type { AppDispatch, RootState } from "../store/store";
import {
  createTransaction,
  updateTransactionAPI,
  calculateBalance,
  // calculateIncome,
  // calculateExpense,
} from "../store/transactionSlice";
import type { Transaction } from "../store/transactionSlice";
import { PencilSquare, PlusCircle, Eye, EyeSlash } from "react-bootstrap-icons";

interface Props {
  editingTransaction: Transaction | null;
  clearEdit: () => void;
}

const TransactionForm = ({ editingTransaction, clearEdit }: Props) => {
  const dispatch = useDispatch<AppDispatch>();
  const { user } = useSelector((state: RootState) => state.auth);

  const [show, setShow] = useState(
    JSON.parse(localStorage.getItem("show") ?? "true"),
  );
  const [title, setTitle] = useState("");
  const [amount, setAmount] = useState("");
  const [isExpense, setIsExpense] = useState(true);

  useEffect(() => {
    if (editingTransaction) {
      setTitle(editingTransaction.title);
      setAmount(editingTransaction.amount.toString());
      setIsExpense(editingTransaction.isExpense);
      setShow(true);
    } else {
      setTitle("");
      setAmount("");
      setIsExpense(true);
    }
  }, [editingTransaction]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user) return;

    const numAmount = Number(amount);
    if (!title || isNaN(numAmount) || numAmount <= 0) return;

    if (editingTransaction) {
      await dispatch(
        updateTransactionAPI({
          id: editingTransaction.id,
          title,
          amount: numAmount,
          isExpense,
          userEmail: user.email,
        }),
      );
      clearEdit();
    } else {
      await dispatch(
        createTransaction({
          title,
          amount: numAmount,
          isExpense,
          userEmail: user.email,
        }),
      );
    }

    dispatch(calculateBalance());

    setTitle("");
    setAmount("");
    setIsExpense(true);
  };

  const toggleShow = () => {
    const newShow = !show;
    setShow(newShow);
    localStorage.setItem("show", JSON.stringify(newShow));
  };

  return (
    <div className="mb-2 position-relative" style={{ width: "100%" }}>
      <div className="d-flex justify-content-end mb-1">
        <button
          className="btn btn-outline-primary"
          onClick={toggleShow}
          style={{ width: "40px", height: "40px", padding: 0 }}
          title={show ? "Hide Form" : "Show Form"}
        >
          {show ? <EyeSlash /> : <Eye />}
        </button>
      </div>

      <div
        style={{
          transition: "all 0.3s ease",
          maxHeight: show ? "1000px" : "0px",
          overflow: "hidden",
        }}
      >
        {show && (
          <form
            className="card p-4 shadow-sm"
            onSubmit={handleSubmit}
            style={{ minWidth: "350px" }}
          >
            <h5 className="card-title mb-3 d-flex align-items-center">
              {editingTransaction ? (
                <>
                  <PencilSquare className="me-2 text-warning" /> Edit
                  Transaction
                </>
              ) : (
                <>
                  <PlusCircle className="me-2 text-success" /> Add Transaction
                </>
              )}
            </h5>

            <input
              type="text"
              className="form-control mb-2"
              placeholder="Title"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              required
            />
            <input
              type="number"
              className="form-control mb-2"
              placeholder="Amount"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              required
            />

            <div className="form-check mb-3">
              <input
                className="form-check-input"
                type="checkbox"
                checked={isExpense}
                onChange={(e) => setIsExpense(e.target.checked)}
                id="isExpenseCheck"
              />
              <label className="form-check-label" htmlFor="isExpenseCheck">
                Is Expense
              </label>
            </div>

            <button className="btn btn-primary w-100">
              {editingTransaction ? "Update Transaction" : "Add Transaction"}
            </button>
          </form>
        )}
      </div>
    </div>
  );
};

export default TransactionForm; this is my transactionsForm import { useDispatch, useSelector } from "react-redux";
import { useEffect } from "react";
import {
  deleteTransactionAPI,
  calculateBalance,
} from "../store/transactionSlice";
import type { Transaction } from "../store/transactionSlice";
import type { AppDispatch, RootState } from "../store/store";

interface Props {
  onEdit: (t: Transaction) => void;
}

const TransactionList = ({ onEdit }: Props) => {
  const dispatch = useDispatch<AppDispatch>();
  const { user } = useSelector((state: RootState) => state.auth);

  const transactions = useSelector((state: RootState) => {
    const email = state.auth.user?.email;
    return state.transactions.transactions.filter(
      (tx) => tx.userEmail === email,
    );
  });

  // ðŸ”¥ auto recalc balance
  useEffect(() => {
    dispatch(calculateBalance());
  }, [transactions.length, dispatch]);

  const handleDelete = async (id: string) => {
    if (!user) return;
    await dispatch(deleteTransactionAPI(id));
  };

  return (
    <div className="transaction-scroll-wrapper">
      <ul className="list-group">
        {transactions.length === 0 ? (
          <li className="list-group-item text-center text-muted">
            No transactions yet
          </li>
        ) : (
          transactions.map((t) => (
            <li
              key={t.id}
              className={`list-group-item d-flex justify-content-between align-items-center ${
                t.isExpense
                  ? "list-group-item-danger"
                  : "list-group-item-success"
              }`}
            >
              {t.title}
              <span>
                â‚¹{t.amount.toLocaleString()}
                <button
                  className="btn btn-sm btn-outline-primary ms-2"
                  onClick={() => onEdit(t)}
                >
                  Edit
                </button>
                <button
                  className="btn btn-sm btn-outline-dark ms-2"
                  onClick={() => handleDelete(t.id)}
                >
                  X
                </button>
              </span>
            </li>
          ))
        )}
      </ul>
    </div>
  );
};

export default TransactionList; this is my transactionList import { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import TransactionForm from "./TransactionForm";
import TransactionList from "./TransactionList";
import BalanceSummary from "./Balance";
import ExpenseChart from "./ExpenseChart";
import ExpenseBarChart from "./ExpenseBarChart";
import { logout } from "../store/authSlice";
import type { AppDispatch, RootState } from "../store/store";
import type { Transaction } from "../store/transactionSlice";

const TransactionsPage = () => {
  const dispatch = useDispatch<AppDispatch>();
  const navigate = useNavigate();
  const { user } = useSelector((state: RootState) => state.auth);
  const getNameFromEmail = (email?: string) => {
    if (!email) return "";

    const namePart = email.split("@")[0]; // nikunj.jain
    return namePart
      .split(".") // ["nikunj", "jain"]
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
      .join(" ");
  };

  const [editingTransaction, setEditingTransaction] =
    useState<Transaction | null>(null);

  const handleLogout = () => {
    dispatch(logout());
    navigate("/login");
  };

  return (
    <div className="app-container">
      {/* ===== HEADER ===== */}
      <div className="mb-3 text-center">
        <h1 className="app-title">Expense Tracker</h1>
      </div>

      {/* ===== USER INFO ROW ===== */}
      <div className="d-flex justify-content-between align-items-center mb-3">
        <h5 className="mb-0">Hi {getNameFromEmail(user?.email)}</h5>
        <button className="btn btn-outline-danger" onClick={handleLogout}>
          Logout
        </button>
      </div>

      {/* ===== MAIN GRID ===== */}
      <div className="app-grid">
        {/* LEFT COLUMN */}
        <div className="left-col">
          <BalanceSummary />
          <TransactionForm
            editingTransaction={editingTransaction}
            clearEdit={() => setEditingTransaction(null)}
          />
          <TransactionList onEdit={setEditingTransaction} />
        </div>

        {/* RIGHT COLUMN */}
        <div
          className="right-col"
          style={{
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
          }}
        >
          <ExpenseChart />
          <ExpenseBarChart />
        </div>
      </div>
    </div>
  );
};

export default TransactionsPage; this is my TransactionsPage import { useSelector } from "react-redux";
import type { RootState } from "../store/store";

const BalanceSummary = () => {
  const { balance, income, expense } = useSelector(
    (state: RootState) => state.transactions,
  );

  return (
    <div className="card p-3 mb-2 text-center">
      <h4 className="fw-bold">
        Balance:{" "}
        <span
          className={
            balance < 0
              ? "text-danger"
              : balance > 0
                ? "text-success"
                : "text-secondary"
          }
        >
          â‚¹{balance.toLocaleString()}
        </span>
      </h4>
      <div className="d-flex justify-content-between">
        <span className="text-success">Income: â‚¹{income.toLocaleString()}</span>
        <span className="text-danger">
          Expense: â‚¹{expense.toLocaleString()}
        </span>
      </div>
    </div>
  );
};

export default BalanceSummary; this is my Balance import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Tooltip,
  Legend,
} from "chart.js";

import { Bar } from "react-chartjs-2";
import { useSelector } from "react-redux";
import type { RootState } from "../store/store";

ChartJS.register(CategoryScale, LinearScale, BarElement, Tooltip, Legend);

const ExpenseBarChart = () => {
  const income = useSelector((state: RootState) => state.transactions.income);
  const expense = useSelector((state: RootState) => state.transactions.expense);
  const data = {
    labels: ["income", "expense"],
    datasets: [
      {
        label: "Amount",
        data: [income, expense],
        backgroundColor: ["#28a745", "#dc3545"],
        borderRadius: 8,
      },
    ],
  };

  const options = {
    responsive: true,
    plugins: { legend: { display: false } },
    scales: { y: { beginAtZero: true } },
  };

  if (income === 0 && expense === 0) {
    return <p className="text-center text-muted">No Income or Expense yet</p>;
  }
  return (
    <div className="card p-3">
      <h5 className="text-center mb-3">Income vs Expenses</h5>
      <Bar data={data} options={options} />
    </div>
  );
};

export default ExpenseBarChart; this is my ExpenseBarChart import { Doughnut } from "react-chartjs-2";
import { Chart as ChartJS, ArcElement, Tooltip, Legend } from "chart.js";
import { useSelector } from "react-redux";
import type { RootState } from "../store/store";

ChartJS.register(ArcElement, Legend, Tooltip);

const ExpenseChart = () => {
  const transactions = useSelector(
    (state: RootState) => state.transactions.transactions,
  );

  const expenseMap: Record<string, number> = {};

  transactions
    .filter((trx) => trx.isExpense)
    .forEach((tx) => {
      expenseMap[tx.title] = (expenseMap[tx.title] || 0) + tx.amount;
    });

  const data = {
    labels: Object.keys(expenseMap),
    datasets: [
      {
        label: "Expenses",
        data: Object.values(expenseMap),
        backgroundColor: [
          "#dc3545",
          "#fd7e14",
          "#ffc107",
          "#198754",
          "#0d6efd",
        ],
        borderWidth: 1,
      },
    ],
  };

  if (Object.keys(expenseMap).length === 0) {
    return <p className="text-center text-muted">No Expense to show</p>;
  }
  return (
    <div className="card p-3 shadow-sm">
      <h5 className="text-center mb-3">Expense Distribution</h5>
      <Doughnut data={data} />
    </div>
  );
};

export default ExpenseChart; this is my ExpenseChart Help me update all these so that I only get to see the transactions, balance and chart for the loggedin user only. Also when I refresh I should still be able to see the transactions. I am getting data from a json server backend which is locally hosted. give me detailed explaination of all the changes